# 1.객체 지향 설계
1) 객체 지향은 실세계의 개체를 속성과 메서드가 결합한 형태의 객체로 표현하는 기법
2) 객체 지향 구성요소
- 클래스
  - 특정 객체 내에 있는 변수와 메서드를 정의하는 일종의 틀
  - 객체 지향 프로그래밍에서 데이터를 추상화 하는 단위
  - 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현
  - 속성은 변수의 형태로, 행위는 메서드 형태로 선언
- 객체
  - 물리적, 추상적으로 자신과 다른 것을 식별 가능한 대산
  - 클래스에서 정의한 것을 토대로 메모리에 할당됨
  - 객체마다 각가의 상태와 식별성을 가짐
- 메서드
  - 클래스로부터 생성된 객체를 사용하는 방법
  - 객체가 메시지를 받아 실행해야 할 객체의 구체적인 연산
  - 전통적 시스템의 함수 또는 프로시저에 해당하는 연산 기능
- 메시지
  - 객체 간 상호 작용을 하기 위한 수단
  - 객체에게 어떤 행위를 하도록 지시하는 방법
  - 객체 간의 상호 작용은 메시지를 통해 이루어짐
  - 에시지는 객체에서 객체로 전달됨
- 인스턴스
  - 객체 지향 기법에서 클래스를 통해 만든 실제의 실형 객체
  - 실제로 메모리상에 할당
- 속성
  - 한 클래스 내에 속한 객체들이 가지고 있는 데이터 값들을 다위별로 정의
  - 성질, 분류, 식별, 수량, 현재 상태 등에 대한 표현 값
3) 객체 지향 기법
- 캡슐화
  - 서로 연관된 데이터와 함수를 함께 묶어 외부와 경계를 만들고 필요한 인터페이스만을 밖으로 드러내는 기법
  - 결합도가 낮아지고 재사용이 용이
  - 인터페이스가 단순화 됨
  - 인터페이스가 단수화됨
  - 정보 은닉과 관계가 깊음
  - 변경 발생 시 오류의 파급 효과가 적음
- 상속성
  - 상위 클래스의 속성과 메서드를 하위 클래스에서 재정의 없이 물려받아 사용하는 기법
- 다항성
  - 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
  - 상속받은 여러 개의 하위 객체들이 다른 형태의 특성을 갖는 객체로 이용될 수 있는 성질
  - 오버로딩, 오버라이딩이 대표적
- 추상화
  - 공통 성질을 추출하여 추상 클래스를 설정하는 기법
  - 과정 추상화 자료 추상화, 제어 추상화
- 정보 은닉
  - 코드 내부 데이터와 메서드를 숨기고 공개 인터페이스를 통해서만 접근이 가능하도록 하는 코드 보안 기술
  - 필요하지 않은 정보는 접근할 수 없도록 하여 한 모듈 또는 하부 시스템이 다른 모듈의 구현에 영향을 받지 않게 설계됨.
  - 모듈 내부의 자료 구조와 접근 동작들에만 수정을 국한하지 않기 때문에 요구사항 등 변화에 따른 수정이 가능
  - 모듈 사이의 독립성을 유지하는 데 도움이 됨
  - 설계에서 은닉되어야 할 기본 정보로는 IP 주소와 같은 물리적 코드, 상세 데이터 구조 등이 존제
- 관계성
  - 연관화
    - is memver of 관계
    - 클래스와 객체의 참조 및 이용관계
    - 같은 계층에 속하는 클래스들 사이의 상호 의존성을 보여주는 비계층적 관계성을 나타냄
  - 집단화
    - is part of part whole
    - 서로 관련 있는 여러 개의 객체를 묶어 한 개의 상위 객체를 만드는 특징이 있음
    - 일반화와 달리 상위 클래스의 성질들이 하위 클래스로 상속되지 않음
  - 분류화
    - is instance of
    - 공통된 속성에 의해 정의된 객체 구성원들의 인스턴스
  - 일반화
    - is a
    - 클래스들 간의 개념적인 포함 관계
    - 상위 클래스의 특성을 하위 클래스가 상속 받음
  - 특수화
    - is a
    - 상위 클래스의 특성들을 상속받으면서 하위 클래스에서 나름대로 수정을 가하고 자기 자신의 고유 특성을 갖는 관계
4) 객체 지향 설계 원칙
- 단일 책임 원칙
  - 하나의 클래스는 하나의 목정르 위해 생성되며 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는데 집중되어 있어야 한다는 원칙
  - 객체 지향 프로그래밍의 5원칙 중 4원칙의 기초
- 개방 폐쇄 원칙
  - 소프트웨어의 구성요소는 확장에는 열려있고 변경에는 닫혀있어야 한다는 원칙
- 리스코프 치완의 원칙
  - 서브 타입은 어디서나 자신의 기반 타입으로 교체할 수 있어야 한다는 원칙
- 인터페이스 분리 원칙
  - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙
  - 클라이언트가 사용하지 않는 인터페이스 때문에 영향을 받아서는 안된다는 원칙
- 의존성 역전의 원칙
  - 실제 사용 관계는 바뀌지 않으며 추상을 매개로 메시지를 주고 받음으로써 관계를 최대한 느슨하게 하는 원칙
5) 객체 지향 분석 개념
- OOA 사용자의 요구사항을 분석하여 요구되는 문제와 관련된 모든 클래스, 속성과 연산, 관계등으로 나누어서 분석하는 기법
- 데이터 행위를 하나로 묶어 객체를 정의하고 추상화시킨다
- 코드 재사용에 의한 프로그램 생산성 향상 및 요구에 따른 시스템은 쉬운 변경이 가능
6) 객체 지향 방법론 종류
- OOSE - 야콥슨
  - 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용되는 방법론
  - 분석 설계 구현 단계로 구성
  - 기능적 요구사항 중심의 시스템
- OMT - 럼바우
  - 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론
  - 객체 모델링 -> 동적모델링 -> 기능 모델링 순으로 진행
    - 객체 모델링
      - 정보 모델링이라고 하며, 시스템에서 요구하는 객체를 찾고 객체 간의 관계를 정의하는 모델링
      - 가장 중요하며 선행되어 진행
      - 객체 다이어그램을 활용하여 표현
    - 동적 모델링
      - 시간의 흐름에 따라 객체들 상이의 제어흐름, 동작 순서 등의 동적인 행위를 표현하는 모델링
      - 상태 다이어 그램을 활용하여 표현
    - 기능 모델링
      - 프로세스들의 자료 흐름을 중심으로 처리과정을 표현하는 모델링
      - 자료 흐름도를 활용하여 표현
- OOD - 부치
  - 설계 문서화를 강조하여 다이어그램 중심으로 개발하는 방법론
  - 분석과 설계의 분리가 불가능
  - 분석하는 데 이용된 객체 모델의 설계 시 적용
- 추가적인 coad와 yourdon 방법론 e-r 다이어그램을 사용하여 객체의 행위를 모델링하며 객체 식별 구조 식별 주체 정의 속성 및 관계의 서비스 정의 등의 과정으로 구성되는 객체 지향 분석 방법
- Wirfs Brock 방법론은 분석과 설계 간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행하는 분석 방법
# 2. 디자인 패턴
1) 디자인 패턴 개념
   - 디자인 패턴은 소프트웨어 공학의 설계에서 공통으로 발생하는 문제에 대해 자주 쓰는 설계 방법을 정리한 패턴
   - 디자인 패턴을 참고하여 개발할 경우 개발의 효율성과 유지보수성, 운용성등의 품질이 높아지며, 프로그램의 최적화에 도우이 된다
2) 디자인 패턴 구성 요소
   - 디자인 패턴에는 패턴의 이름 문제 및 배경 솔류션 사례 결과 샘플 코드로 구성
   - 패턴 이름
     - 디자인 패턴을 부를 때 사용하는 이름과 디자인 패턴의 유형
   - 문제 및 배경
     - 디자인 패턴이 사용되는 분야 또는 배경 해결하는 문제를 의미
   - 솔루션
     - 디자인 패터을 이루는 요소들 관계 협동 과정
   - 사례
     - 디자인 패턴의 간단한 적용 사례
   - 결과
     - 디자인 패턴을 사용하면 얻게 되는 이점이나 영향
   - 샘플 코드
     - 디자인 패턴이 적용된 원시 코드
3) 디자인 패턴 유형
- 목적
  - 생성
    - 객체 인스턴스 생성에 관여 클래스 정의와 객체 생성 방식을 구조화 캡슐화를 수행하는 패턴
  - 구조
    - 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
  - 행위
    - 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴
- 범위
  - 클래스
    - 클래스 간 관련성
    - 컴파일 타임에 정적으로 결정
  - 객체
    - 객체 간 관련성을 다루는 패턴
    - 런타임에 동적으로 결정
4) 디자인 패턴 종류
a) 생성 패턴
  - builder
    - 복잡한 인스턴스를 조립하여 만드는 구조로 복함 객체를 생성할 때 객체를 생성하는 방법과 객체를 구현하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴
    - 생성과 표기를 분리해서 복잡한 객체를 생성
  - Prototype
    - 처음부터 일반적인 원형을 만들어 놓고 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결저되도록 설정하여 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴
    - 기존 객체를 복제함으로써 객채를 생성
  - Factory Method
    - 상위 클래스에서 객체를생성하는 인터페이스를 정의하고 하위 클래스에서 인터페이스를 생성하도록 하는 방식으로 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴
    - 생성할 객체의 클래스를 국한하지 않고 객체를 생성
  - Abstract
    - 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴으로 이 패턴을 통해 생성된 클래스에는 사용자에게 인터페이스를 제공하고 구체적인 구현은 conrete product 클래스에서 이루어지는 특징을 갖는 디자인 패턴
    - 동일한 주제의 다른 팩토리를 묶음
  - Singleton
    - 전역 변수를 사용하지 않고 개체를 하나만 생성하도록 하며 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴
    - 한 클래스에 한 객체만 조재하도록 제한
b) 구조 패턴
- Bridge
  - 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴
  - 구현뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우 활용
- Decorator
  - 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴으로 기능 확장이 필요할 때 객체 간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 상속의 대안으로 사용하는 디자인 패턴
  - 객체의 결합을 통해 기능을 동적으로 유연하게 확장
- Facade
  - 복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템간 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴으로 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순화한 인터페이스 제공을 통해 접근설을 높일 수 있는 패턴
  - Flyweight
    - 다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 릌래스 화하여 공유함으로써 메모리를 절약하고, 클래스의 경량화를 목적으로 하는 디자인 패턴
    - 여러개의 가상 인스턴스를 제공하여 메모리 절감
  - Proxy
    - 실체 객체에 대한 대리 객체로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 정보 은닉의 역할도 수행하는 디자인 패턴
    - 특정 객체로의 접근을 제어하기 위한 용도를 사용
- Composite
  - 객체들의 관계를 트리 구조로 구성하여 부분 전체 계층을 표현하는 패터능로 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴
  - 복합 객체와 단일 객체를 동일하게 취급
- Adapter
  - 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴으로 상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태로  사용되는 디자인 패턴
  - 인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움

c) 행위 패턴
- Mediator
  - 객체 지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 객체 지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있기 때문에 이를 해결하는 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체 지향의 목표를 달성하게 해결해주는 패턴
  - 상호 작용의 유연한 변경을 지원
- Interpreter
  - 언어의 다양한 해석 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해설할 수 있게 만드는 디자인 패턴
  - 문법 자체를 캡슐화하여 사용
- Iterator
  - 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 방법을 제공하는 디자인 패턴
  - 내부구조를 노출하지 않고 복잡 객체의 원소를 순차적으로 접근 기능하게 해주는 행위 패턴
- Template Method
  - 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴으로 일반적으로 상위 클래스에는 추상 메서드를 통해 기능의 골격을 제공하고 하위 클래스의 메서드에는 세부 처리를 구체화하는 방식으로 사용하여 코드 양을 줄이고 유지보수를 용이하게 만드는 특징을 갖는 디자인 패턴
  - 상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행
- Ovserver
  - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대 다의 의존성을 가지며 상호 작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴
  - 객체의 상태 변화에 따라 다른 객체의 상태로 연동 일대다 의존
- State
  - 객체 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시 코드의 수정을 최소화할 수 있고 유지보수의 편의성도 갖는 디자인 패턴
  - 객체의 상태에 따라 행위 내용을 변경
- Visitor
  - 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 먼드는 편탠으로 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확정 할 때 사용하는 디자인
  - 특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위
- Command
  - 실행될 기능을 캡슐화 함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴으로 하나의 추상 클래스에 메서드를 만들어 각 명령어들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴
  - 요구사항을 객체로 캡슐화
- Strategy
  - 알고리즘 군을 정의하고 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴으로 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 디자인 패턴
  - 행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환
- Memento
  - 클래스 설계 관점에서 객체의 정보를 저장할 ㅍ리요가 있을 때 적용하는 디자인 패턴으로 UNdo기능을 개발할 때 사용하는 디자인 패턴
  - 객체를 이전 상태로 복구시켜야 하는 경우 작업취소 요청 가능
- Chain of Responsibilty
  - 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능한데 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리를 할 수 있도록 연결한 디자인 패턴
  - 한 요청을 2개 이상의 객체에서 처리
d)  디자인 패턴의 장단점
- 장점
  - 요구사항 변경에 따른 소스 코드 변경을 최소화할 수 있게 해줌
  - 소프트웨어 코드의 품질을 향상시킬 수 있음
  - 설계 변경 요청에 대한 유연한 대처가 가능
  - 범용적인 코딩 스타일 적용 가능
  - 개발자 간의 원할한 의사소통 가능
  - 재사용을 통한 개발 시간 단축 기능
  - 소프트웨어 구조 파악이 용이
  - 객체 지향 설계 및 구현의 생산성을 높이는 데 적합
  - 소프트웨어의 품질과 생산성을 향상시킬 수 있음
- 단점
  - 객체 지향 설계 구현 위주로 사용
  - 초기 투자 비용의 부담
