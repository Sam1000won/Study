# 1. 공통 모듈 설계
## 1.1 공통모듈
1) 모듈의 개념
- 모듈은 크게 독립된 하나의 소프트웨어 또는 하드웨어 단위를 지칭하는 용어
- 모듈화를 통해 분리된 시스템의 기능들로 서브프로그램, 서브,소프트웨어 내의 단위 프로그램, 작업 단위 등과 같은 의미
2) 모듈의 특징
- `독립성`
  - 각가의 모듈은 상대적인 독립성을 가짐
  - 모듈의 독립성은 결합도와 응집도에 의한 측정
- `다양한 조합`  
  - 모듈 내부에는 모듈을 하나로 통합하는 수많은 조합이 존재할 수 있음
- `재사용`
  - 모듈은 단독으로 컴파일할 수 없으며 재사용 가능
- `영향 최소화`
  - 독립성이 높은 모듈일 수록 수정 시 다른 모듈에 영향을 거의 미치지 않음
3) 공통 모듈의 개념
  - 전체 프로그램의 기능 중 특정 기능을 처리할 수 있는 실행 코드를 의미
  - 자체적인 컴파일 가능하고 다른 프로그램에서 재사용이 가능
  - 여러 기능 및 프로그램에서 공통으로 사용할 수 있는 모듈을 의미하며 날짜 처리를 위한 유틸
## 1.2 공통 모듈 원칙
- `정확성(Correctness)`
  - 해당 기능이 실제 시스템 구현 시 필요한지 아닌지 알 수 있도록 정확하게 작성
- `명확성(Clarity)`
  - 해당 기능에 대해 일관되게 이해되고 한 가지로 해석 될 수 있도록 작성
- `완전성(Completeness)`
  - 시스템이 구현될 때 필요하고 유구되는 모든 것을 기술
- `일관성(Consistency)`
  - 공통 기능 간에 상호 충돌이 없도록 작성
- `추적정(Traceability)`
  - 공통 기능에 대한 요구사항 출처와 관련 시스템 등의 유기적 관계에 대한 식별이 가능하도록 작성
## 1.3 모듈화
1) 모듈화 개념
   - 모듈화는 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화함으로써 소프트웨어 제품의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리를 쉽게 하는 기법
   - 소프트웨어의 성능을 향상시키거나 복잡한 시스템의 수정, 재사용, 유지 관리 등이 용이하도록 기능 단위의 모듈로 분해하는 설계 및 구현 방법
- 모듈화 기법
  - `루틴(Routine)`
    - 소프트웨어에서 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령들의 모임
  - `메인 루틴(main Routine)`
    - 프로그램의 주요한 부분이며, 전체의 개략적인 동작 절차를 표시하도록 만들어진 루틴
    - 메인 루틴은 서브 루틴을 호출함
  - `서브 루틴 subroutine`
    - 메인루틴에 의해 필요할 때마다 호출되는 루틴
2) 모듈화 필요성
- 모듈의 크기가 너무 작아 모듈 개수가 많아지면 모듈 간 통합 비용이 많이 발생
- 모듈의 크기가 너무 크면 모듈 간의 통합 비용이 줄어드는 대신 모듈 당 개발 비뵹이 커짐
3) 바람직한 모듈 설계 방안
- 모듈의 독립성과 재사용성을 높이기 위해 결합도는 낮추고 응집도는 높인다
- 모듈의 복잡도와 중복성을 줄이고 일관성을 유지한다
- 모듈의 기능은 예측이 가능해야 하며, 지나치게 제한적이면 안된다
- 적당한 모듈의 크기를 유지한다.
- 모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다.
- 유지보수가 용이하고 이식성을 고려해야 한다
## 1.4 모듈화 유형
- `응집도`
  - 모듈 내부에서 구성요소 간에 밀접한 관계를 맺고 있는 정도
  - 응집도가 높을수록 필요한 요소들로 구성되어 있고 낮을수록 관련이 적은 요소들로 구성
- `결합도`
  - 모듈과 모듈 간에 어느 정도 관련성이 있는지를 나타내는 정도
  - 관련이 적을수록 모듈의 독립성이 높아 모듈 간 영향이 적어짐
## 1.5 Fan-In, Fan-Out
- Fan-In, Fan-Out 개념
  - 소프트웨어의 구성요소인 모듈을 계층적으로 분석하기 위해 팬인 팬아웃을 활용
  - 팬인과 아웃을 통해 복잡도를 측정할 수 있다
- Fan-in
  - 개념 : 어떤 모듈을 제어하는 모듈의 수
  - 모듈 숫자 계산: 모듈 자신을 기준으로 모듈에 들어오면 팬인
  - 고려사항
    - 패인이 높으면 재사용 측면에서 설계가 잘 된것이지만, 단일 장애점 발생 가능
    - 관리 비용 및 테스트 비용증가
- Fan-Out
  - 개념: 어떤 모듈에 의해 제어되는 호출 모듈 수
  - 모듈 숫자 계산: 모듈 자신을 기준으로 모듈에서 나가면 팬아웃
  - 고려사항
    - 팬아웃이 높을 경우 불필요한 모듈 호출 여부 검토 필요
    - 팬아웃이 높을 경우는 단순화 여부 검토 필요
- 시스템 복잡도를 최적화하기 위해서는 패인은 높게 팬아웃은 낮게 설계해야 한다
## 2. 설계 모델링
1) 설계 모델링 개념
- 설계 모델링은 요구사항 분석 단계에서 규명된 필수 기능들의 구체적인 구현 방법을 명시하는 기법
- 소프트웨어 요구되는 기능과 성능 조건들을 만족하는 소프트웨어의 내부기능, 구조 및 동적 행위들을 모델링하여 표현 분석 검증하는 과정
2) 설계 모델링 원칙
- 소프트웨어 설계는 변경이 쉽도록 구조화되어야 한다
- 하나의 함수 안에 특저 ㅇ기능을 수행하는 데 필요한 자료만 사용할도록 규제
- 독립적이고 기능적인 특성을 지닌 모듈 단위로 분할 설계
- 계층적 구조를 가져야함
3) 설계 모델링 유형
- 구조적 모델링
  - 소프트웨어를 구성하는 컴포넌트들의 유형 인터페이스 내부 설계 구조 및 이들의 상호 연결 구조를 모델링
  - 시스템의 구성요소들과 이들 사이의 구조적인 관계 특징 모델링
    - ex) 프로시저 데이터 구조 모듈 파일구조
- 행위 모델링
  - 소프트웨어의 구성요소들의 기능들과 이들이 언제 어떤한 순서로 기능을 수행하고 상호 작용하는지 모델링
  - 시스템의 구성요소들이 언제 어떠한 순서로 수행되는 가와 같은 동적인 특성을 모델링
    - ex) 입,출력 데이터, 데이터 흐름, 데이터 변환,저장 등..
## 2.2 소프트웨어 설계 유형
- 소프트웨어 설계 유형에는 자료 구조 설계, 아키텍처 설계, 인터페이스 설계 프로시저 설계, 협약에 의한 설계가 있음
- `자료 구조 설계 (Data Stucture Design)`
  - 요구 분석 단계에서 생성된 정보를 바탕으로 소프트웨어를 구현하는데 필요한 자료 구조를 변환 하는 과정
- `아키텍처 설계`(Architecture Design)
  - 예비 설계 또는 상위 수준 설계
  - 소프트웨어 시스템의 전체 구조를 기술
  - 소프트웨어를 구성하는 컴포넌트 간의 관계를 정의
- `인터페이스 설계`(Interface Design)
  - 소프트웨어와 상호 작용하는 컴퓨터 시스템 사용자 등이 어떻게 통신하는지 기술
- `프로시저 설계`(Procedure Design)
  - 프로그램 아키텍처의 컴포넌트를 소프트웨어 컴포넌트의 프로시저 서술로 변환하는 과정
- `협약에 의한 설계`(Design by Contract)
  - 클래스에 대한 여러 가정을 공유하도록 명세한 설계
  - 소프트웨어 컴포넌트에 대한 정확한 인터페이스 명세를 위해 선행조건, 결과조건, 불변조건을 나타내는 설계 방법
    - `선행조건`(Precondition)
      - 컴포넌트의 오퍼레이션 사용 전에 참이 되어야 할 조건
    - `결과조건`(Postcondition)
      - 사용 후 만족되어야 할 조건
    - `불변조건`(inveariant)
      - 오퍼레이션이 실행되는 동안 항상 만족 되어야 하는 조건
## 2.3 소프트웨어 설계 원리
- 시스템 명세가 명확한 경우 모든 것을 새로 개발하는 작업에는 하향식 설계가 적합하며 기존 컴포넌트들을 조합하여 시스템을 개발하는 경우에는 상향식 설계가 적합
- `자료 구조,아키텍처, 인터페이스,프로시저,협약에 의한 설계`는 **상위**속하고, `모듈` 설계는 **하위**
- *상향식 설계*
  - 하위 기능들로부터 시작하여 제일 상위에 있는 기능 접근해가는 방식
- *하향식 설계*
  - 소프트웨어 설계 시 제일 상위에 있는 기능에서 시작하여 기능을 하위 기능으로 분할해 가면서 설계
## 2.4 코드 설계
1) 코드 설계 개념
- 코드 설계는 데이터의 분류나 조합을 쉽게 하기 위해 사물을 표현하는 코드 설계 기법
2) 코드 기능
- `표준화`
  - 정보들 종류 모양 크기 등의 일정한 기준에 따라 통일적을 표현기능
- `분류`
  - 정보들을 동일한 특성을 가진 데이터를 그룹화하여 나누는 기능
- `식별`
  - 다른 것과 구별 가능
- `배열`
  - 일렬의 순소로 나열할 수 있는 기능
- `간소화`
  - 정보의 표현을 간소화해서 나타낼 수 있는 기능
- `연상`
  - 정보를 표현하고자 하는 대상체 뜻과 의미가 코드에 내포되게 하는 기능
- `암호화`
  - 정보를 표현하고자 하는 대상체 뜻과 의미가 코드에 내포되게 하는 기능
- `오류 검출`
  - 정보의 외부 표현을 감추고자 하는 기능
3) 코드 설계 종류
- `연상 코드`(Mnemonic Code)
  - 코드만 보고 대상을 연상할 수 있도록 명칭 일부를 약호 형태로 넣어 구성된 코드
- `블록 코드`(Block Code)
  - 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 코드
- `순차 코드`(Sequence Code)
  - 일정한 기준에 따라 순서대로 일련번호를 부여한 코드
- `표의 숫자 코드`(Significant Digit Code)
  - 대상 자료의 물리적인 수치인 길이,넓이,용량 등을 표시한 코드
- `십진 코드`(Decimal Code)
  - 10진수 형태로 표현할 코드
- `그룹 분류식 코드`(Group Classification)
  - 대상을 기준에 따라 대,중,소 분류로 구분하여 번호를 부여한 코드
4) 코드 설계 절차
1. 코드화 항목 설정
2. 코드와 목적 설정
3. 코드화 대상 확인
4. 코드화 범위 결정
5. 코드 사용 기간 설정
6. 코드화 항목의 특성 분석
7. 코드화 방식 결정
8. 문서화
5) 코드 오류 종류
- `사본 오류`(Transcripition)
  - 한 자리를 잘못 표기한 경우
  - 필사 오류,오자 오류라고 불림
- `전위 오류`(Transposition)
  - 연속된 두 글자가 서로 바뀌어 표기된 경우
- `생략 오류`(Omission)
  - 한 글자를 빼먹고 기술한 경우
- `첨가 오류`(Addition)
  - 한 글자를 추가되어 기술한 경우
- `이중 전위 오류`(Double Transposition)
  - 전위 오류가 중복 발생한 경우
## 2.5 HIPO
1) HIPO 개념
분석 및 설계, 문서화할 때 사용되며 하향식 소프트웨어 개발을 위한 문서화 도구
2) HIPO 특징
- 체계적인 문서 관리가 가능
- 기호, 도표 등을 사용해서 보기가 쉽고 이해가 쉽다
- 기능과 자료의 의존 관계를 동시에 표현할 수 있음
- 변경, 유지보수가 용이
- 시스템의 기능을 고유 모듈들로 분할하여 이들 간의 인터페이스를 계층구조로 표현한 것을 HIPO 차트라고 한다
3) 차트의 종류
- `가시적 도표`(Visual Table of Contents)
  - 시스템의 전체적인 기능과 흐름을 보여주는 계층구조도
- `총체적 도표`(Overview Diagram)
  - 입,출,처리에 대한 정보를 제공하는 도표
  - 프로그램을 구성하는 기능을 기술
- `세부적 도표`(Detail Diagram)
  - 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표
## 3.소프트웨어 아키텍처
### 3.1소프트웨어 아키텍처 개념
- 소프트웨어 아키텍처는 여러 가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템 구조
- 소프트웨어를 설계하고 전개하기 위한 지침과 원칙
### 3.2 소프트웨어 아키텍처의 필요성
- 주요 이해관계자들 간의 관점 조율을 통한 시스템을 최적화
- 아키텍처는 시스템의 비기능적인 요소에 집중해서 만들어지고 기능요소를 고려
### 3.3 소프트웨어 아키텍처 프레임 워크
1) 소프트웨어 아키텍처 프레임워크
- 소프트웨어 아키텍처 프레임워크는 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준
  (1471)
2) 소프트웨어 아키텍처 프레임워크 구성요소
- `아키텍처 명세서`(Architectual Description)
  - 아키텍처를 기록하기 위한 산출물들
  - 이해관계자들의 시스템에 대한 관심을 관점에 맞추어 작성한 뷰로 표현
  - 개별 뷰, 뷰 개괄 문서, 인터페이스 명세 등이 있음
- `이해관계자`(Stakeholder)
  - 시스템 개발에 관련된 모든 사람과 조직
  - 고객, 최종사용자, 개발자, 프로젝트 관리자, 유지보수자, 마케팅 담당자 등을 포함
- `관심사`(Concerns)
  - 사용자 입장
    - 기능적인 기능, 신뢰성, 보안,사용성 등의 품질
  - 유지보수자 입장
    - 유지보수의 용이성
  - 개발자 입장
    - 적은 비용과 인력으로 개발
- `관점`(Viewpoint)
  - 개별 뷰를 개발할 때 토대가 되는 패턴이나 양식
  - 시스템에 대한 아키텍처 설명에는 하나 이상의 뷰로 구성
- `근거`(Rationale)
  - 아키텍처 결정 근거
  - 회의 결과,보고 결과
- `목표`(Mission)
  - 환경 안에서 한 명 이상의 이해관계자들이 의도하는 시스템의 목적, 사용, 운영방법
- `환경`(Environment)
  - 시스템에 영향을 주는 요인으로 개발,운영 등의 외부 요인 등으로 시스템에 영향을 주는 요인
- `시스템`(systeam)
  - 각 애플리케이션, 서브시스템, 시스템의 집합,제품군 등의 구현
### 3.4 소프트웨어 아키텍처 4+1
1) 소프트웨어 아키텍처 4+1 뷰 개념
- 소프트웨어 아크택처 뷰는 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
- 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 이들 4개 구조가 서로 충돌되지 않는, 시스템의 요구사항을 충족시키지지를 증명하기 위해 체크 방법으로 유스케이스를 사용한다.
- 유스케이스 뷰
  - 유스케이스 또는 아키텍처를 도출하고 설계하며 다른 뷰를 검증하는데 사용되는 뷰
  - 외부 행위자에 의해 인식되는 시스템의 기능 요구사항을 보여주는 데초점
  - 사용자,설계자,개발자,테스트
- 논리 뷰
  - 시스템의 기능적인 요구사항이 어떻게 제공되는지 설명해주는 뷰
  - 설계자, 개발자
- 프로세스 뷰
  - 시스템의 비기능적인 속성으로서 자원의 효율적인 사용, 병행 실행, 비동기, 이벤트 처리 등을 표현한 뷰
  - 개발자, 시스템 통합 관점
- 구현 뷰
  - 개발 환경 안에서 정적인 소프트웨어 모듈의 구성을 보여주는 뷰
  - 컴포넌트 구조와 의존성을 보여주고 컴포넌트에 관환 부가적인 정보 정의
- 배포 뷰
  - 컴포넌트가 물리적인 아키텍처에 어떻게 배치되는가를 매핑해서 보여주는 뷰
  - 물리적 시스템을 구성하고 있는 각 부분들의 분산 형태와 설치에 초점

### 3.5 소프트웨어 아키텍처 비용 평가 모델
1) 소프트웨어 아키텍처 비용 평가 모델 개념
- 소프트웨어 아키텍처 비용 평가 모델은 아키텍처 접근법이 품질 속성에 미치는 영향을 판단하고 아키텍처의 적합성을 평가하는 모델
2) 소프트웨어 아키텍처 비용 평가 모델 정류
- SAAM
  - 변경 용이성과 기능성에 집중, 평가가 용이하여 경험이 없는 조직에서도 활용 가능한 비용 평가 모델
- ATAM
  - 아키텍처 품질 속성을 만족시키는지 판단 및 품질 속성들의 이해 상충관계까지 평가하는 모델
- CBAM
  - 시스템 아키텍처 분석 중심으로 경제적 의사결정에 대한 요구를 충족하는 비용 평가 모델
- ADR
  - 소프트웨어 아키텍처 구성요소 간 응집도를 평가하는 모델
- ARID
  - 전체 아키텍처가 아닌 특정 부분에 대한 품질요소에 집중하는 비용 평가 모델
### 3.6 소프트웨어 아키텍처 패턴
1) 아키텍처 팬텀 개념
- 소프트웨어 아키텍처 패턴은 외부에서 인식할 수 있는 특성이 담긴 소프트웨어의 골격이 되는 기분 구조
- 소프트웨어 아키텍처 패턴은 소프트웨어를 설계할 때 참조할 수 있는 전형적인 해결 방식
- 소프트웨어 아키텍처에서 일반적으로 발생하는 문제점들에 대한 일반화되고 재사용 가능한 솔루션
2) 소프트웨어 아키텍처 패턴 필요성
- 소프트웨어 개발 시 상황별 소프트웨어 아키텍처 패턴을 수립 적용하여 고객과 의사소통을 통해 고객의 요구사항을 만족시키고, 소프트웨어 개발 생산성과 품질 확보가 가능
- 데이터 중심 아키텍처는 공유 데이터 저장소를 통해 접근자 간의 통신이 이루어지므로 각 접근자의 수정과 확장이 용이
- 이미 검증된 구조로 개발하기 때문에 소프트웨어 개발의 안정적으로 수행이 가능
- 시스템의 특성을 개발 전에 예측이 가능
3) 소프트웨어 아키텍처 패턴 유형
- 계층화 패턴
  - 계층화 패턴은 시스템을 계층으로 구분하여 구성하는 패턴
  - 각 하위 모듈들은 특정한 수준의 추상화를 제공하고, 각 계층은 다음 상위 계층에 서비스를 제공
  - 계층화 패턴은 서로 마주 보는 두 개의 계층 사이에서만 상호 작용이 이루어짐
- 클라이언트 서버 패턴
  - 클라이언트 서버 패턴은 하나의 서버와 다수의 클라이언트로 구성된 패턴
  - 사용자가 클라이언트를 통해서 서버에 서비스를 요청하면 서버는 클라이언트에게 서비스 제공
  - 서버는 계속 클라이언트로부터 요청을 대기
- 파이프 필터 패턴
  - 데이터 스트림을 생성하고 처리하는 시스템에서 사용 가능한 단방향 패턴
  - 서브 시스템이 입력 데이터를 받아 처리하고 결과를 다음 서브 시스템으로 넘겨주는 과정을 반복
  - 필터 컴포넌트는 재사용성이 좋고 추가가 쉽기 때문에 확장이 용이하나 필터 간 데이터 이동에서 데이터 변환 오버헤드가 발생
- 브로커 패턴
  - 브로커 패턴은 분리된 컴포넌트들로 이루어진 분산 시스템에서 사용되고 이 컴포넌트들은 원격 서비스 실행을 통해 상호 작용이 가능한 패턴
  - 브로커 컴포넌트는 컴포넌트 간의 통신을 조정하는 역할 수행
  - 서버는 자신의 기능들 클라이언트가 브로커에 서비스를 요청하면 브로커는 클라이언트는 브로커에 서비스를 요청하면 브로커는 클라이언트를 자신의 레지스트리에 있는 적합한 서비스로 리다이렉션함
- 모델 뷰 컨트롤러 패턴
  - MVC 패턴이라고 하는 이 패턴은 대화형 애플리케이션을 모델, 뷰, 컨트롤 뷰 3개의 서브 시스템으로 구조화 하는 패턴
    - 모델
      - 핵심 기능과 데이터 보관
    - 뷰
      - 사용자에게 정보 표시나 이상의 뷰가 정의될 수 있음
    - 컨트롤
      - 사용자로부터 요청을 입력받아 처리
  - MVC패턴은 각 부분이 별도의 컴포넌트로 분리되어 있어 서로 영햐을 받지 않고 개발 작업 수행 가능
  - 컴포넌트를 분리하여 코드의 효율적인 재사용을 가능하게 하고 여러 개의 뷰가 있어야 하는 대화형 애플리케이션 구축에 적합
- 마스터 슬레이브 패턴
  - 마스터 슬레이브 패턴은 연산 통신 조정을 책임지는 마스터와 제어되고 동기화되는 대상인 슬레이브로 구성되는 패턴
  - 일반적으로 실시간 시스템에서 사용
### 3.7 소프트웨어 아키텍처 품질 속성
- 소프트웨어 아키텍처 품질 속성은 아키텍처 비용 평가를 위해서 필요한 사항으로 특정 품질에 대한 요구사항을 명세한 내영 최적의 아키텍처를 선택하기 위한 핵심 요소
- 소프트웨어 아키텍처 품질 속성은 이해 관계자들의 품질 요구사항을 반영하여 결정
- 품질 속성은 시스템 품질 속성, 비지니스 품질 속성, 아키텍처 품질 속성으로 구성
  - 시스템 품질 속성
    - 가용성, 변경 용이성, 성능, 보안성, 사용 편의성, 시험 용이성
  - 비즈니스 품질 속성
    - 시장 적시성, 비용과 이익, 시스템 프로젝트 생명 주기, 목표 시장, 신규 발매 일정, 노후 시스템과 통합
  - 아키텍처 품질 속성
    - 개념적 무결성, 저확성과 안정성, 개발 용이성
  
