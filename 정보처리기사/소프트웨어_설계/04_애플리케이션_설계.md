# 1. 공통 모듈 설계
## 1.1 공통모듈
1) 모듈의 개념
- 모듈은 크게 독립된 하나의 소프트웨어 또는 하드웨어 단위를 지칭하는 용어
- 모듈화를 통해 분리된 시스템의 기능들로 서브프로그램, 서브,소프트웨어 내의 단위 프로그램, 작업 단위 등과 같은 의미
2) 모듈의 특징
- `독립성`
  - 각가의 모듈은 상대적인 독립성을 가짐
  - 모듈의 독립성은 결합도와 응집도에 의한 측정
- `다양한 조합`  
  - 모듈 내부에는 모듈을 하나로 통합하는 수많은 조합이 존재할 수 있음
- `재사용`
  - 모듈은 단독으로 컴파일할 수 없으며 재사용 가능
- `영향 최소화`
  - 독립성이 높은 모듈일 수록 수정 시 다른 모듈에 영향을 거의 미치지 않음
3) 공통 모듈의 개념
  - 전체 프로그램의 기능 중 특정 기능을 처리할 수 있는 실행 코드를 의미
  - 자체적인 컴파일 가능하고 다른 프로그램에서 재사용이 가능
  - 여러 기능 및 프로그램에서 공통으로 사용할 수 있는 모듈을 의미하며 날짜 처리를 위한 유틸
## 1.2 공통 모듈 원칙
- `정확성(Correctness)`
  - 해당 기능이 실제 시스템 구현 시 필요한지 아닌지 알 수 있도록 정확하게 작성
- `명확성(Clarity)`
  - 해당 기능에 대해 일관되게 이해되고 한 가지로 해석 될 수 있도록 작성
- `완전성(Completeness)`
  - 시스템이 구현될 때 필요하고 유구되는 모든 것을 기술
- `일관성(Consistency)`
  - 공통 기능 간에 상호 충돌이 없도록 작성
- `추적정(Traceability)`
  - 공통 기능에 대한 요구사항 출처와 관련 시스템 등의 유기적 관계에 대한 식별이 가능하도록 작성
## 1.3 모듈화
1) 모듈화 개념
   - 모듈화는 프로그램이 효율적으로 관리될 수 있도록 시스템을 분해하고 추상화함으로써 소프트웨어 제품의 성능을 향상시키거나 시스템의 수정 및 재사용, 유지 관리를 쉽게 하는 기법
   - 소프트웨어의 성능을 향상시키거나 복잡한 시스템의 수정, 재사용, 유지 관리 등이 용이하도록 기능 단위의 모듈로 분해하는 설계 및 구현 방법
- 모듈화 기법
  - `루틴(Routine)`
    - 소프트웨어에서 특정 동작을 수행하는 일련의 코드로 기능을 가진 명령들의 모임
  - `메인 루틴(main Routine)`
    - 프로그램의 주요한 부분이며, 전체의 개략적인 동작 절차를 표시하도록 만들어진 루틴
    - 메인 루틴은 서브 루틴을 호출함
  - `서브 루틴 subroutine`
    - 메인루틴에 의해 필요할 때마다 호출되는 루틴
2) 모듈화 필요성
- 모듈의 크기가 너무 작아 모듈 개수가 많아지면 모듈 간 통합 비용이 많이 발생
- 모듈의 크기가 너무 크면 모듈 간의 통합 비용이 줄어드는 대신 모듈 당 개발 비뵹이 커짐
3) 바람직한 모듈 설계 방안
- 모듈의 독립성과 재사용성을 높이기 위해 결합도는 낮추고 응집도는 높인다
- 모듈의 복잡도와 중복성을 줄이고 일관성을 유지한다
- 모듈의 기능은 예측이 가능해야 하며, 지나치게 제한적이면 안된다
- 적당한 모듈의 크기를 유지한다.
- 모듈 간의 효과적인 제어를 위해 설계에서 계층적 자료 조직이 제시되어야 한다.
- 유지보수가 용이하고 이식성을 고려해야 한다
## 1.4 모듈화 유형
- `응집도`
  - 모듈 내부에서 구성요소 간에 밀접한 관계를 맺고 있는 정도
  - 응집도가 높을수록 필요한 요소들로 구성되어 있고 낮을수록 관련이 적은 요소들로 구성
- `결합도`
  - 모듈과 모듈 간에 어느 정도 관련성이 있는지를 나타내는 정도
  - 관련이 적을수록 모듈의 독립성이 높아 모듈 간 영향이 적어짐
## 1.5 Fan-In, Fan-Out
- Fan-In, Fan-Out 개념
  - 소프트웨어의 구성요소인 모듈을 계층적으로 분석하기 위해 팬인 팬아웃을 활용
  - 팬인과 아웃을 통해 복잡도를 측정할 수 있다
- Fan-in
  - 개념 : 어떤 모듈을 제어하는 모듈의 수
  - 모듈 숫자 계산: 모듈 자신을 기준으로 모듈에 들어오면 팬인
  - 고려사항
    - 패인이 높으면 재사용 측면에서 설계가 잘 된것이지만, 단일 장애점 발생 가능
    - 관리 비용 및 테스트 비용증가
- Fan-Out
  - 개념: 어떤 모듈에 의해 제어되는 호출 모듈 수
  - 모듈 숫자 계산: 모듈 자신을 기준으로 모듈에서 나가면 팬아웃
  - 고려사항
    - 팬아웃이 높을 경우 불필요한 모듈 호출 여부 검토 필요
    - 팬아웃이 높을 경우는 단순화 여부 검토 필요
- 시스템 복잡도를 최적화하기 위해서는 패인은 높게 팬아웃은 낮게 설계해야 한다
## 2. 설계 모델링
1) 설계 모델링 개념
- 설계 모델링은 요구사항 분석 단계에서 규명된 필수 기능들의 구체적인 구현 방법을 명시하는 기법
- 소프트웨어 요구되는 기능과 성능 조건들을 만족하는 소프트웨어의 내부기능, 구조 및 동적 행위들을 모델링하여 표현 분석 검증하는 과정
2) 설계 모델링 원칙
- 소프트웨어 설계는 변경이 쉽도록 구조화되어야 한다
- 하나의 함수 안에 특저 ㅇ기능을 수행하는 데 필요한 자료만 사용할도록 규제
- 독립적이고 기능적인 특성을 지닌 모듈 단위로 분할 설계
- 계층적 구조를 가져야함
3) 설계 모델링 유형
- 구조적 모델링
  - 소프트웨어를 구성하는 컴포넌트들의 유형 인터페이스 내부 설계 구조 및 이들의 상호 연결 구조를 모델링
  - 시스템의 구성요소들과 이들 사이의 구조적인 관계 특징 모델링
    - ex) 프로시저 데이터 구조 모듈 파일구조
- 행위 모델링
  - 소프트웨어의 구성요소들의 기능들과 이들이 언제 어떤한 순서로 기능을 수행하고 상호 작용하는지 모델링
  - 시스템의 구성요소들이 언제 어떠한 순서로 수행되는 가와 같은 동적인 특성을 모델링
    - ex) 입,출력 데이터, 데이터 흐름, 데이터 변환,저장 등..
## 2.2 소프트웨어 설계 유형
- 소프트웨어 설계 유형에는 자료 구조 설계, 아키텍처 설계, 인터페이스 설계 프로시저 설계, 협약에 의한 설계가 있음
- `자료 구조 설계 (Data Stucture Design)`
  - 요구 분석 단계에서 생성된 정보를 바탕으로 소프트웨어를 구현하는데 필요한 자료 구조를 변환 하는 과정
- `아키텍처 설계`(Architecture Design)
  - 예비 설계 또는 상위 수준 설계
  - 소프트웨어 시스템의 전체 구조를 기술
  - 소프트웨어를 구성하는 컴포넌트 간의 관계를 정의
- `인터페이스 설계`(Interface Design)
  - 소프트웨어와 상호 작용하는 컴퓨터 시스템 사용자 등이 어떻게 통신하는지 기술
- `프로시저 설계`(Procedure Design)
  - 프로그램 아키텍처의 컴포넌트를 소프트웨어 컴포넌트의 프로시저 서술로 변환하는 과정
- `협약에 의한 설계`(Design by Contract)
  - 클래스에 대한 여러 가정을 공유하도록 명세한 설계
  - 소프트웨어 컴포넌트에 대한 정확한 인터페이스 명세를 위해 선행조건, 결과조건, 불변조건을 나타내는 설계 방법
    - `선행조건`(Precondition)
      - 컴포넌트의 오퍼레이션 사용 전에 참이 되어야 할 조건
    - `결과조건`(Postcondition)
      - 사용 후 만족되어야 할 조건
    - `불변조건`(inveariant)
      - 오퍼레이션이 실행되는 동안 항상 만족 되어야 하는 조건
## 2.3 소프트웨어 설계 원리
- 시스템 명세가 명확한 경우 모든 것을 새로 개발하는 작업에는 하향식 설계가 적합하며 기존 컴포넌트들을 조합하여 시스템을 개발하는 경우에는 상향식 설계가 적합
- `자료 구조,아키텍처, 인터페이스,프로시저,협약에 의한 설계`는 **상위**속하고, `모듈` 설계는 **하위**
- *상향식 설계*
  - 하위 기능들로부터 시작하여 제일 상위에 있는 기능 접근해가는 방식
- *하향식 설계*
  - 소프트웨어 설계 시 제일 상위에 있는 기능에서 시작하여 기능을 하위 기능으로 분할해 가면서 설계
## 2.4 코드 설계
1) 코드 설계 개념
- 코드 설계는 데이터의 분류나 조합을 쉽게 하기 위해 사물을 표현하는 코드 설계 기법
2) 코드 기능
- `표준화`
  - 정보들 종류 모양 크기 등의 일정한 기준에 따라 통일적을 표현기능
- `분류`
  - 정보들을 동일한 특성을 가진 데이터를 그룹화하여 나누는 기능
- `식별`
  - 다른 것과 구별 가능
- `배열`
  - 일렬의 순소로 나열할 수 있는 기능
- `간소화`
  - 정보의 표현을 간소화해서 나타낼 수 있는 기능
- `연상`
  - 정보를 표현하고자 하는 대상체 뜻과 의미가 코드에 내포되게 하는 기능
- `암호화`
  - 정보를 표현하고자 하는 대상체 뜻과 의미가 코드에 내포되게 하는 기능
- `오류 검출`
  - 정보의 외부 표현을 감추고자 하는 기능
3) 코드 설계 종류
- `연상 코드`(Mnemonic Code)
  - 코드만 보고 대상을 연상할 수 있도록 명칭 일부를 약호 형태로 넣어 구성된 코드
- `블록 코드`(Block Code)
  - 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 코드
- `순차 코드`(Sequence Code)
  - 일정한 기준에 따라 순서대로 일련번호를 부여한 코드
- `표의 숫자 코드`(Significant Digit Code)
  - 대상 자료의 물리적인 수치인 길이,넓이,용량 등을 표시한 코드
- `십진 코드`(Decimal Code)
  - 10진수 형태로 표현할 코드
- `그룹 분류식 코드`(Group Classification)
  - 대상을 기준에 따라 대,중,소 분류로 구분하여 번호를 부여한 코드
4) 코드 설계 절차
1. 코드화 항목 설정
2. 코드와 목적 설정
3. 코드화 대상 확인
4. 코드화 범위 결정
5. 코드 사용 기간 설정
6. 코드화 항목의 특성 분석
7. 코드화 방식 결정
8. 문서화
5) 코드 오류 종류
- `사본 오류`(Transcripition)
  - 한 자리를 잘못 표기한 경우
  - 필사 오류,오자 오류라고 불림
- `전위 오류`(Transposition)
  - 연속된 두 글자가 서로 바뀌어 표기된 경우
- `생략 오류`(Omission)
  - 한 글자를 빼먹고 기술한 경우
- `첨가 오류`(Addition)
  - 한 글자를 추가되어 기술한 경우
- `이중 전위 오류`(Double Transposition)
  - 전위 오류가 중복 발생한 경우
## 2.5 HIPO
1) HIPO 개념
분석 및 설계, 문서화할 때 사용되며 하향식 소프트웨어 개발을 위한 문서화 도구
2) HIPO 특징
- 체계적인 문서 관리가 가능
- 기호, 도표 등을 사용해서 보기가 쉽고 이해가 쉽다
- 기능과 자료의 의존 관계를 동시에 표현할 수 있음
- 변경, 유지보수가 용이
- 시스템의 기능을 고유 모듈들로 분할하여 이들 간의 인터페이스를 계층구조로 표현한 것을 HIPO 차트라고 한다
3) 차트의 종류
- `가시적 도표`(Visual Table of Contents)
  - 시스템의 전체적인 기능과 흐름을 보여주는 계층구조도
- `총체적 도표`(Overview Diagram)
  - 입,출,처리에 대한 정보를 제공하는 도표
  - 프로그램을 구성하는 기능을 기술
- `세부적 도표`(Detail Diagram)
  - 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표
## 3.소프트웨어 아키텍처
### 3.1소프트웨어 아키텍처 개념
- 소프트웨어 아키텍처는 여러 가지 소프트웨어 구성요소와 그 구성요소가 가진 특성 중에서 외부에 드러나는 특성, 그리고 구성요소 간의 관계를 표현하는 시스템 구조
- 소프트웨어를 설계하고 전개하기 위한 지침과 원칙
### 3.2 소프트웨어 아키텍처의 필요성
- 주요 이해관계자들 간의 관점 조율을 통한 시스템을 최적화
- 아키텍처는 시스템의 비기능적인 요소에 집중해서 만들어지고 기능요소를 고려
### 3.3 소프트웨어 아키텍처 프레임 워크
1) 소프트웨어 아키텍처 프레임워크
- 소프트웨어 아키텍처 프레임워크는 소프트웨어 집약적인 시스템에서 아키텍처가 표현해야 하는 내용 및 이들 간의 관계를 제공하는 아키텍처 기술 표준
  (1471)
2) 소프트웨어 아키텍처 프레임워크 구성요소
- `아키텍처 명세서`(Architectual Description)
  - 아키텍처를 기록하기 위한 산출물들
  - 이해관계자들의 시스템에 대한 관심을 관점에 맞추어 작성한 뷰로 표현
  - 개별 뷰, 뷰 개괄 문서, 인터페이스 명세 등이 있음
- `이해관계자`(Stakeholder)
  - 시스템 개발에 관련된 모든 사람과 조직
  - 고객, 최종사용자, 개발자, 프로젝트 관리자, 유지보수자, 마케팅 담당자 등을 포함
- `관심사`(Concerns)
  - 사용자 입장
    - 기능적인 기능, 신뢰성, 보안,사용성 등의 품질
  - 유지보수자 입장
    - 유지보수의 용이성
  - 개발자 입장
    - 적은 비용과 인력으로 개발
- `관점`(Viewpoint)
  - 개별 뷰를 개발할 때 토대가 되는 패턴이나 양식
  - 시스템에 대한 아키텍처 설명에는 하나 이상의 뷰로 구성
- `근거`(Rationale)
  - 아키텍처 결정 근거
  - 회의 결과,보고 결과
- `목표`(Mission)
  - 환경 안에서 한 명 이상의 이해관계자들이 의도하는 시스템의 목적, 사용, 운영방법
- `환경`(Environment)
  - 시스템에 영향을 주는 요인으로 개발,운영 등의 외부 요인 등으로 시스템에 영향을 주는 요인
- `시스템`(systeam)
  - 각 애플리케이션, 서브시스템, 시스템의 집합,제품군 등의 구현
### 3.4 소프트웨어 아키텍처 4+1
1) 소프트웨어 아키텍처 4+1 뷰 개념
- 소프트웨어 아크택처 뷰는 고객의 요구사항을 정리해 놓은 시나리오를 4개의 관점에서 바라보는 소프트웨어적인 접근 방법
- 4개의 분리된 구조로 구성되는 아키텍처 개념을 제시하고, 이들 4개 구조가 서로 충돌되지 않는, 시스템의 요구사항을 충족시키지지를 증명하기 위해 체크 방법으로 유스케이스를 사용한다.
