# 요구사항 분석
## 1. 요구분석 기법
### 1. 요구분석(Requirements Analysis) 개념
- 요구분석은 도출된 요구사항 간 상숭을 해결하고 소프트웨어의 범위를 파악하여 외부 환경과의 상호 작용을 분석하는 과정
- 요구분석은 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
  - 외부 환경 : 소프트 웨어, 하드 웨어, 네트워크
### 2. 요구분석의 특징
- 요구 분석은 소프트웨어 개발의 실제적인 첫 단계로 사용자의 요구에 대한 이해하는 단계
- 분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용할 수 있음
- 구체적인 명세를 위해 소단위 명세서가 필요할 수 있음
- 개발 비용이 가장 많이 소요되는 단계
- 요구 분석 중 도메인 분석(Domain Analysis)은 요구에 대한 정보를 수집하고 배경을 분석하여 이를 토대로 모델링
- **소단위 명세서** : 데이터 흐름도에 나타나 있는 처리 항목을 1~2페이지 정도의 소규모 분량으로 용약하여 작성하는 논리 명세서
### 3.요구사항 분석 단계 절차
- 요구사항 분석을 통해서 요구사항을 기술할 때에는 요구사항의 확인(Validation),요구사항 구현의 검증(Verification), 비용 추정이 가능하도록 충분하고 정확하게 기술
- **요구사항 분류**
  - 요구사항이 기능인지 비 기능인지 확인
  - 요구사항이 소프트웨어에 미치는 영향의 범위를 파악
  - 요구사항이 소프트웨어 생명주기 동안 병경이 발생하는지를 확인
  - 하나 이상의 상위 요구사항에서 유도된 것인지 또는 이해관계자나 다른 원천으로부터 직접 발생한 것인지 분류
- **개념 모델링 생성 및 분석**
  - 요구사항을 더 쉽게 이해할 수 있도록 현실 세계의 상황을 단순화, 개념적으로 표현한 것을 모델이라고 하며, 모델링은 이러한 모델을 만드는 과정
  - 객체 모델, 데이터 모델, 상태, 모델 등 다양한 모델 작성 가능
  - 모델링 표기를 위해 DFD,UML 다이어그램 E-R다이어그램 사용
- **요구사항 할당**
  - 요구사항을 만족시키기 위한 아키텍처 구성요소를 식별하는 활동
  - 다른 구성요소와 어떻게 상호 작용하는지 분석을 통해 추가적인 요구 사항을 발견 가능
- **요구사항 협상**
  - 두 명의 이해관계자가 서로 상충되는 내용을 요구하는 경우 어느 한쪽으로 지지하기보다는 적절한 지점에서 합의를 위한 기법
  - 요구사잉이 서로 충돌되는 경우 각각 우선순위를 부여하면 무엇이 더 중요한지 인식할 수 있으므로 문제 해결에 도움이 됨
- **정형 분석**
  - 형식적으로 정의된 의미를 지닌 언어로 요구사항을 표현
  - 구문과 의미를 갖는 정형화된 언어를 사용할 수학적 기호로 표현
  - 요구사항의 마지막 단계에서 이루어짐
### 4. 요구사항 분석기술
- 청취 기술, 민터뷰와 질문 기술, 분석 기술, 중재 기술, 관찰 기술, 작성 기술, 조직 기술, 모델 작성 기술이 있음
- **청취 기술** : 이해관계자로부터 의견을 듣는 기술
- **인터뷰와 질문 기술** : 이해관계자를 만나 정보를 수집하고 이야기를 나누는 기술
- **분석 기술** : 추출된 요구사항에 대해 충돌,중복, 누락 등의 분석을 통해 완전성과 일관성을 확보하는 기술
- **중재 기술**: 이해관계자들의 상반된 유구에 대한 중재기술
- **관찰 기술**: 사용자가 작업하는 것을 관찰하면서 사용자가 언급하지 않은 미묘한 의미를 탐지할 수 있는 기술
- **작성 기술**: 문서 작성 기술
- **조직 기술**: 수집된 방대한 정보를 일관성 있는 정보로 구조화하는 능력
- **모델 작성 기술**: 수집한 자료를 바탕으로 제어의흐름, 기능 처리, 동작 행위, 정보내용 등을 이해하기 쉽도록 모델로 작성하는 기술
### 5.요구사항 분석에 따른 모델링 기법
#### 5.1 데이터 흐름도(DFD: Data Flow Digram)
1) 데이터 흐름도 개념
  - 데이터 흐름도는 데이터가 각 프로세스를 따라 흐르면서 변화된 모습을 나타낸 그림
  - 시스템 분석과 설계에서 매우 유용하게 사용되는 다이어그램
  - 데이터 흐름도는 시스템의 모델링 도구로서 가장 보편적으로 사용되는것
  - 자료흐름 그래프 or 버블 차트라고 함
2) 데이터 흐름도 특징
- `구조적 분석 기법`에 이용
- 데이터의 흐름에 중심을 두는 분석용 도구
- 제어의 흐름은 중요하지 않는다
- 제어의 흐름은 중요하지 않다
- 시간 흐름을 명확하게 표현 못함.
3) 데이터흐름도 구성요소
  - 처리기, 데이터 흐름, 데이터 저장소, 단말
  - **처리기(Process)**: 입력된 데이터를 원하는 형태로 변환하여 출력하기 위한 과정 O으로 표시
  - **데이터 흐름(Data Flow)**: DFD의 구성요소(프로세스,데이터 저장소, 외부 엔티티)들 간의 주고 받는 데이터 흐름을 나타내며, DFS에서 화살표로 표시
  - **데이터 저장소(Data Store)**: 데이터를 저장된 장소, DFS에서 = 로표시
  - **단말 (Terminator)**: 프로세스 처리 과정에서 데이터가 발생하는 시작과 종료를 나타내고, 사각형으로 표시 하고 외부 엔티티 이름을 넣음
 #### 5.2 자료 사전
 1) **자료 사전(DD: Data Dictionary)**
 - 자료사전은 자료 요소,자료 요소들의 집합, 자료의 흐름, 자료 저장소의 의미와 그들 간의 관계, 관계 값, 범위, 단위들을 구체적으로 명시하는 사전
 - 자료사전은 파일 혹은 데이터베이스에 있는 자료에 대한 자료 또는 각 자료 항목에 주어진 이름과 길이 그리고 서술과 같은 데이터를 포함하는 참조를 위한 직업
2) **자료사전 기호**
   - **=**: `자료의 정의로써 '~으로 구성되어 있다'는 것을 나타내는 기호`
   - 정의는 주석을 사용하여 의미를 기술하며 자료흐름과 자료저장소에 대한 구성 내영을 설명하고 자료 원소에 대하여 값이나 단위를 나타내는 기호
   - **+**: **자료 연결**
   - **()**: **자료 생략 가능함을 나타내는 기호**
   - **{}**: **자료의 반복을 나타내는 기호**
   - **[]**:**자료의 선택을 나타내는 기호**
   - **\**\**: **자료의 설명을 나타내는 기호**
3) 자료사전 작성 원칙
- **자료의 의미 기술**
  - 자료의 의미는 주석을 통해서 기술
  - 자료의 의미를 기술할 때는 그 자료가 대상 시스템에서 사용되는 적합한 뜻을 표현해야 함
  - 중복되는 기술을 회피하는 것은 간결하고 이해하기 쉬운 자료 사전을 작성하는데 중요함
- **자료 구성항목의 기술**
  - 구성항목들을 그룹으로 묶음
  - 각 그룹에 대하여 의미 있는 이름을 부여
  - 이름이 붙여진 각 그룹을 다시 정의
- **동의어 규정 준수**
  - 사용자마다 동일한 문서나 자료에 대해 서로 다른 이름들을 갖고 있을 수 있으며 사용자들의 용어를 통일 시키는 것보다 사용하는 용어를 이용하여 자료를 정의하는 것이 간단함
  - 분석가 자료를 하햫식으로 분할하는 과정에서 부주의하게 동의어를 사용할 수 있음
- **자료 정의의 중복 제거**
  - 동일한 자료에 대해 여러 명의 분석가 독립적으로 분석을 시행한다면, 서로 다른 이름을 사용할 수 있기 때문에 자료 정의의 중복 제거 필요
### 6. 요구사항 분석이 어려운 이유
- 개발자와 사용자 간의 지식이나 표현의 차이가 커서 상호 이해가 쉽지 않다.
- 사용자의 요구사항이 모호하고 불명확하다.
- 소프트웨어 개발 과정 중에 요구사항이 계속 변할 수 있다.
- 사용자의 요구는 예외가 많아 열거와 구조화가 어려운 편이다.
### 6.1 UML
#### 6.1 UML(Unified Modeling Language)의 개념
- UML은 객체 지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용되는 모델링 기술과 방법론을 통해서 만든 표준화된 범용 모델링 언어
#### 6.2 UML 특징
- **가시화언어**
  - 개념 모델 작성 시 적고 의사소통이 용이
- **구축 언어**
  - 다양한 프로그래핑 언어로 실행 시스템 예측 가능
  - UML을 소스코드로 변환하여 구축 가능, 역 변환하여 역공학 가능
- **명세화 언어**
  - 정확한 모델 제시, 완전한 모델 작성 기능
- **문서화 언어**
  - 시스템에 대한 평가 및 의사 소통의 문서
#### 6.3 UML 구성요소
- **사물(Things)**
  - `추상적인 개념`으로, 주제를 나타내는 요소
  - 단어 관점에서 `명사`또는 `동사`를 의미
- **관계(Relationships)**
  - `사물의 의미를 확장하고 명확히 하는 요소`
  - 사물과 사물을 연결하여 관계를 표현하는 요소
  - 단점 과정에서 `형용사` 또는 `부사`
- **다이어그램(Diagrams)**
  - 사물과 관계를 모아 그림으로 표현한 형태
  - 형식과 목적에 따라 9가지로 정의
#### 6.4 UML다이어그램
- 구분에 따라 `구조적`,`행위적` 다이어그램으로 구분
- 컴포넌트, 배치 다이어그램은 `구현 단계`에서 사용되는 다이어 그램
1) **구조적,정적 다이어그램 (Strutural/Static Diagram)**
   - Class(클래스)
     - 시스템 내 클래스의 `정적 구조`
     - `속성(Attribute)/동작(Behavior)` 구성
     - 시스템의 구조를 파악하고 구조상의 문제점 도출 가능
     - 클래스와 클래스, 클래스의 속성 사이의 관계를 표현
  - **Object(객체)**
    - 클래스에 속한 사물, `인스턴스`를 *특정 시점*의 객체와 객체 사이의 관계로 표현
    - 객체 인스턴스를 나타내는 대신 실제 클래스를 사용
    - 연관된 모든 `인스턴스`
  - **Componenl(컴포넌트)**
    - 코드 컴포넌트 기반의 `물리적 구조 표현`
    - *실질적 프로그래핑 작업*
  - **Deployment(배치)**
    - 컴포넌트 사이의 `종속성 표현`
    - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
  - **Composite Structure(복합체 구조)**
    - 클래스나 컴포넌트가 복합 구조를 갖는 경우 `내부 구조` 표현
  - **Package(패키지)**
    - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현
2) **행위적/동적 다이어 그램(Behavioral/Dynamic)**
  - **Usecase(유스케이스)**
    - *사용자* 관점에서 `시슽ㅁ의 활종을 표현`
    - 유스케이스 시스템의 `기능적 요구` 정의에 활용
  - **sequence(시퀀스)**
    - 객체간 상호 작용을 `메시지 흐름`으로 표현
    - `객체 사이 메시지를 보내는 시간`을 표현
    - *교류 다이어그램(Interaction)* 종류로 볼수 있음
  - **Communication**
    - 시퀀스 다이어그램과 같이 동작하에 참여하는 객체들이 주고 받는 메시지를 표현, 메시지뿐 아니라 `객체 간의 연관`까지 표현
  - **State(상태)**
    - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현
    - 모든 가능한 상태와 전이를 표현
    - 집입 조건, 탈출 조건, 상태 전이 등 기술
  - **Activity(활동)**
    - `시스템이 어떤 기능을 수행하는지를 객체의 처리 로직`이나 조건에 따른 `처리의 흐름으로 순서대로 표현`
    - 활동의 순서대로 흐름을 표현
  - **Timing(타이밍)**
    - `객체 상태 변화와 시간 제약을 명시적으로 표현`
#### 6.5 UML 상세
1) **클래스 다이어그램**
   - 클래스 다이어그램의 개념
     - `객체 지향 모델링` 클래스의 속성 및 연산과 클레스 간의 `정적인 관계`를 표현하는 다이어그램이다.
     - 클래스와 클래스 즉 *클래스 속성 사이*의 관계
  - 클래스 다이어그램 구성 요소
    - **클래스 이름**
    - **속성** : 특징에 이름 부여
    - **연산**: 객체에 적응될 메서드를 정의, 클래스 동작을 의미하며, UML에서는 동작에 대한 인터페이스를 지칭
    - **접근 제어자**
      - (-): 클래스 내부 접근만 허용`(private)`
      - (+): 클래스 외부 접근 허용`(public)`
      - (#): 동일 패키지, 파생 클래스에서 접근 가능`(protected)`
      - (~): 동일 패키지 클래스에서 접근 가능`(defaulf)`
2) **유스케이스 다이어그램**
  - 유스케이스 다이어그램 개념
    - 시스템이 제공하고 있는 기능 및 그와 관련된 외부요소를 사용자의 관점에서 표현하는 다이어그램
  - 유스케이스 구성요소
    - **Usecase(유스케이스)**
      - 시스템이 제공해야 하는 서비스
      - 엑터가 시스템을 통해 수행하는 일련의 행위
    - **Actor(엑터)**
      - 사용자가 시스템에 대해 수행하는 역항
      - 시스템과 상호 작용하는 `사람` 혹은 `사물`
    - **Systeam(시스템)**
      - 전체 시스템의 영역 표현
3) **시퀀스 다이어그램**
  - **Sequence(다이어그램)** 개념
    - `객체 간 상호 작용을 메시지 흐름으로 표현`
  - **시퀀스 다이어그램 구성요소**
    - **Object**
      - 객체는 위쪽 표시되며 아래로 생명선을 가짐
      - 객체는 사각형 안에 밑줄 친 이름으로 명시
    - **LifeLine**
      - 객체로부터 뻗어 나가는 `점선`
      - 실제 시간이 흐름에 따라 객체의 생명주기 동안 발생하는 이벤트 명시
    - **Activation**
      - 직사각형은 오퍼레이션이 실행되는 시간을 의미
      - 직사각형이 길어질수록 오퍼레이션 수행시간이 김
    - **Messges**
      - 객체 간의 상호 작용은 메시지 교환으로 이루어짐
      - 한 객체에서 다른 객체로의 메시지를 전달하여 전달받은 객체의 오퍼래이션 수행
#### 6.6 UML 관계
- **연관 관계**
  - 연관관계는 2개 이상의 사물이 서로 관련된 상태를 표현
  - 사물 사이의 실선으로 연결 표시하며 방향성은 화살표로 표현
  - 서로에게 영향을 주는 양방향 관계의 경우 화살표를 생략하고 `실선`으로만 연결
- **의존**
  - 의존 관계는 사물 사이에 서로 연관있으나 필요에 따라 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현
  - 사물의 변화가 다른 사물에도 영향을 미치는 관계
  - 일반적으로 한 클래스가 다른 클래스의 오퍼레이션의 매개변수로 사용하는 경우 타나네는 관계
  - 영향을 주는 사물이 영향을 받는 사물 쪽으로 `점선 화살표`로 연결
- **일반화 관계**
  - 일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지 표현
  - 일반적인 개념을 부모라고하고 구체적인 개념을 자식이라고함
  - 구체적인 사물에서 일반적인 사물 쪽으로 `속이 빈 화살표`를 연결하여 표현
- **실체화**
  - 실체화 관계는 한 객체가 다른 객체에 오퍼레이션을 수행하도록 지정하는 관계를 표현
  - 사물에서 기능 쪽으로 속이 `빈 점선 화살표` 사용
- **포함**
  - 포함관계는 집합 관계의 특수한 형태로 포함하는 사물의 변화가 포함되는 사물에 영향을 미치는 관계를 표현
  - 포함되는 쪽에서 포함하는 쪽으로 속이 채워진 `마름모`를 연결하여 사용
- **집합**
  - 집합 관계는 하나의 사물이 다른 사물에 포함되는 관계 표현
  - 포함되는 쪽에서 포함하는 쪽으로 속이 빈 마름모를 연결하여 표현
#### 6.7 UML확정 모델의 스테리오 타입
- UML의 스테레오 타입은 UML의 기본적 요소 이외의 새로운 요소를 만들어 내기 위한 확장 메커니즘
- 형태는 기존의 UML의 요소를 그대로 사용하지만 내부 의미는 다른 목적으로 사용하도록 확장
- UML 스테레오 타입은`<<>>` 기호를 사용하여 표시
- **UML 스테레오 타입의 유형**
  - **<<include>>**: 하나의 유스케이스가 어떤 시점에 `반드시` 다른 유스케이스를 실행하는 `포함 관계`
  - **<<extend>>**
    - 한의 유스케이스가 어떤 시점에 다른 유스케이를 실행 할 수도 있고 그렇지 않을수도 있는 확장관계
    - 기본 유스케이스 수행 시 `특별 조건을 만족할때 수행`
  - **<<interface>>** : 모든 메서드가 추상 메서드이며 바로 인스턴스를 만들 수 없는 클래스로 추성 메서드와 상수만으로 구성된 클래스
  - **<<entity>>**: 일반적으로 정보 또는 오래 지속되는 연관된 행위를 형성하는 클래스로 유스케이스 처리 흐름이 수행되는 과정에서 기억 장치에 저장되어야 할 정보를 표현하는 클래스
  - **<<boundary>>**: 시스템과 외부 액터와의 상호 작용을 담당하는 클래스
  - **<<control>>**: 시스템이 제공하는 기능의 로직 및 제어를 담당하는 클래스
 ### 3. 애자일(Agile)
 #### 3.1 애자일 방법론 계론
- 에자일 방법론은 소프트웨어 개발방법론의 하나로서 개발과 함깨 `즉시 피드백을 받아서 유동적으로 개발하는 방법`
#### 3.2 애자일 방법론 등장 배경
- 소프트웨어 개발 환경의
  - 소프트웨어 개발 트렌드가 모바일 환경으로 변화
  - 시장 적시성과 잦은 배포의 중요성 부각
- 기존 개발방법론의 한계
  - 전통적 방법론은 문서 및 절차 위주로 변화에 신속한 대응이 어려움
  - 빠르게 적용하고 효율적으로 개발할 수 있는 방법론의 필요성 증가
#### 3.3 애자일 방법론 특징
- 프로젝트의 요구사항은 `기능 중심으로 정의`
- 절차와 도구보다 개인과 소통을 중요하게 생각한다.
- 작업 계획을 짧게 세워 요구 변화에 `유연하고 신속하게 대응`
- 소프르퉤어가 잘 실행되는 데 가치를 둔다
- 고객과의 피드백을 중요하게 생각
#### 3.4 애자일 선언문
- 공정과 도구보다 `개인과 상호작용`
- 계획을 따르기보다 `변화에 대응`
- 포괄적인 문서보다 `동작하는 소프트웨어`
- 계약 협상보다 `고객과의 협력`
#### 3.5 애자일 방법론 유형
- XP(eXteme Programming)
  - 의사소통 개성과 즉각적 피드백으로 소프트에어 품질을 높이기 위한 방법론
  - `실용성`을 강조한 방법론
  - 반복 개발 주기를 가지며, 5가지 가치와 12개의 실천 항목
- **용기(Courage)**
  - 용기를 가지고 자신감 있게 개발(코드를 자성하기 전에 테스트, 빠르게 피드백, 테스트에 부합하지 못하는 코드를 리팩토링할 수 있는 용기)
- **단순성(simplicty)**
  - 필요한 것만 하고 그 이상의 것들은 하지 않음
- **의사소통(Communication)**
  - 개발자,관리자,고객 간의 원활한 소통
- **피드백(Feedback)**
  - 의사소통에 대한 빠른 피드백
- **존중(Respect)**
  - 팀원 간의 상호 존중
----
- 기본원리
  - **짝 프로그래밍(Pair Programming)**
    - 개발자 둘이서 짝으로 코딩하는 원리
  - **공동 코드 소유(Collective Ownership)**
    - 시스템에 있는 코드는 누구든 언제라도 수정 가능하다는 원리
  - **지속적인 통합(CI)**
    - 매일 여러 번씩 소프트웨어를 통합하고 빌드해야 한다는 원리
  - **계획 세우기(Planning Process)**
    - 고객이 요구하는 비즈니스 가치를 정의, 개발자가 필요한 것은 무엇이며 어떤 부분에서 지연할 수 있는지를 알려주어야 한다는 원리
  - **작은 릴리즈(Small Release)**
    - 작은 시스템 먼저 만들고, 짧은 단위로 업데이트한다는 원리
  - **메타포어(Metaphor)**
    - 공통적인 이름 체계와 시스템 서술서를 통해 고객과 개발자 간의 의사소통을 원활하게 한다는 원리
  - **간단한 디자인(Simple Design)**
    - 현재의 요구사항에 적합한 가장 단수한 시스템을 설계한다는 원리
  - **텍스트 기반 개발(TDD: Test Driven Develop)**
    - 작성해야 하는 프로그램에 대한 테스트를 먼저 수행하고 이 테스트를 통과할 수 있도록 실제 프로그램의 코드를 작성한다는 원리
  - **리팩토링(Refactoring)**
    - 프로그램의 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해 시스템 재구성한다는 원리
  - **40시간 작업(40-Hour Work)**
    - 개발자가 피곤으로 인해 실수하지 않도록 일주일에 40시간 이상을 일하지 말아야 한다는 원리
  - **고객 상주(On Site Customer)**
    - 개발자들의 질문에 즉각 대답해 줄 수 있는 고객을 프로젝트에 풀타임으로 상주시켜야 한다는 원리
  - **코드 표준(Coding Standard)**
    - 효과적인 공동  작업을 위해서는 모든 코드에 대한 코딩 표준을 정의해야한다는 원리
- **스트림(Scrum)**
  - 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀
  - 주요 용어
    - **백로그(Backing)**
      - 제품과 프로젝트에 대한 요구사항
    - **스프린트(Sprint)**
      - 2~4주의 짧은 개발 기간으로 반복적 수행으로 개발품질 향상
    - **스크림 미팅(Scrum Meeting)**
      - 매일 15분 정도 미팅으로 To-Do List 계획 수립
      - 데일리 미팅(Daily Meeting)
    - **스크럼 마스터(Scrum Master)**
      -  프로젝트 리터, 스크럼 수행 시 문제를 인지 및 해결하는 사람
    - **스프린트 회고(sprint Retrospective)**
      - 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 여부, 개선점 등을 확인 및 기록
      - 해당 스프린트가 끝난 시점이나 일정 주기로 시행
    - ** 번 다운 차트(Burn Down Chart)**
      - 남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트
      - 백로그는 보통 수직축에 위치하며 시간은 수평축에 위치
- **린(Lean)**
  - 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 ㅇ소를 제거하여 품질을 향상시킨 방법론
  - JIT(Just In Time), 칸반(Kanban) 보드를 사용
  - 린의 7가지 원칙은 낭비 제거, 품질 내재화, 지식 창출, 늦은 확정, 빠른 인도, 사람 존중, 전체 최적화
  - **린(Lean)의 7가지 원칙**
    - **낭비제거**
      - 불필요한 코드나 기능과 같이 상품 가치에 영향을 미치지 않는 모든 것을 제거
    - **품질 내재화**
      - TDD를 통해 코드의 실수를 방지
    - **지식 창출**
      - 개발 과정 진행 중 참여자(기획자, 개발자, 고객 등) 학습의 필요성 존재
    - **늦은 확정**
      - 중요한 문제에 대한 의사 결정을 최대한 미루고 요구사항 변경에 대응
    - **빠른 인도**
      - 결과물을 가능한 한 빨리 제공
      - 사용자의 불확실성이 감소하고 개발자에게는 결합발견의 기회가 주어짐
    - **사람 존중**
      - 상호 간 책임의식과 신뢰 확보
    - **전체 최적화**
      - 사용자 요구사항 수집부터 배포까지 모든 프로세스 최적화
- **크리스탈(Crystal)**
  - 일반적으로 프로세스나 도구보다 사람에게 더 많은 중점을 두는 방법론
  - 생명이 중요하지 않는 시스템에서 작업하는 최대 6명 또는 8명의 공동 배치 소프트웨어 개발자 팀에 적용
- **ASD(Adaptive Software Development)**
  - 개발을 혼란 자체로 규정하고, 혼란을 대전제로 그에 적응할 수 있는 소프트웨어 방법을 제시하기 위해 만들어진 방법
  - `합동 애플리케이션 개발(Joint Application Development)` 사용
- **FDD(Feature Driven Development)**
  - 개발을 상품이나 서비스 단위가 아니라 `신규 기능 단위`로 하는 개발 방법
- 3.6 애자일과 전통적 방법론 비교
  - 계획 수립
    - 에자일 방법론
      - **유동적 범위 설정**
    - 전통적 방법론
      - **확정적 범위 설정**
  - 업무수행
    - 애자일 방법론
      - **팀 중심 업무 수행**
    - 전통적 방법론
      - **관리자 주도적 명령과 통제**
      - **개인 단위로 업무수행**
  - 개발/검증
    - 애자일 방법론
      - **반복 주기 단위로 소프트웨어를 개발/ 검증**
    - 전통적 방법론
      - **분석/ 설계/ 구현/ 테스트를 순차적으로 수행**
  - 팀관리
    - 에자일 방법론
      - **업무 몰입, 팀 평과**
    - 전통적 방법론
      - **경쟁, 개발 평가**
  - 문서화
    - 애자일 방법론
      - **문서화보다는 코드를 강조**
    - 전통적 방법론
      - **상세한 문서화를 강조**
  - 성공요소
    - 애자일 방법론
      - **고객 가치 전달**
    - 전통적 방법론
      - **계획/일정 준수**
  - 유형
    - 애자일 방법론
      - **XP,스크럼,린**
    - 전통적 방법론
      - **폭포수, 프로토타입, 나선형**
