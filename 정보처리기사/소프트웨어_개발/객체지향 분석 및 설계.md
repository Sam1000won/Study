# 1. 모듈
## 1. 모듈의 개요
- 모듈은 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브시스템, S.W 내부 프로그램, 작업 단위
- 단독으로 컴파일, 재사용 가능
- 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미함
- 독립성이 높은 모듈잇수록 수정 및 파급효과 적음, 오류 쉽게 발견
- 결합도, 응집도에 의해 측정, 독립성을 높이려면 결합도는 낮게 응지도는 강하게, 모듈의 크기는 작게 만들어야함
## 2. 결합도(Coupling)
- 모듈간의 상호 의존하는 정도 or 두 모듈 사이의 연관관계를 의미
- 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮아짐
- 결합도가 높으면 시스템 구현 및 유지보수가 어렵다
- Data -> Stamp -> Control -> External -> Common -> Content

## 3. 응집도(Cohesion)
- 내부 요소로 서로 관련 있는 정도, 독립적인 기능으로 정의되어 있는 정도
- 응집도가 강할수록 품질이 높고 낮으면 낮다
- Coincidental -> Logical -> Temporal -> Procedural -> Communication -> Sequential -> Functional
## 4. Fan-In,Out
- 호출하는 모듈수
- 출력되는 모듈수
- 시스템의 복잡도로 알수 있음
- 팬인이 높으면 재사용 측면에서 잘 만듬, 단일 장애점이 발생할 수 있으므로 중점적 관리 및 테스트 필요
- 팬 아웃이 높을수록 다른 모듈을 호출하고 있는지 검토, 단순화 시킬지 여부를 검토 필요
- 시스템 복잡도를 최적화 하려면 팬인은 높게 아웃은 낮게 설계

# 2.공통 모듈
## 1. 공통 모듈 개요
- 여러 프로그램이 공용으로 쓰는 모듈
- 계산식이나 인증 같은 것들
- 재사용성 확보와 중복 개발 회피를 위해 설계 과정에서 공통 부분을 식별하고 명세하는 작업 필요
- 기능을 명확히 이해 할 수 있어야함
-----
- Correcteness 정확성
    - 기능이 필요한것을 정확히 작성
- Clarity 명확성
    - 중의적으로 해석이 안되게 작성
- Completeness 완전성
    - 구현을 위한 모든 것을 기술
- Consistency 일관성
    - 공통 기능간의 상호 충돌이 안일어나게 작성
- Treaceability 추적성
    - 출처, 관계를 파악할 수 있도록 작성

## 2. 재사용성
- 비용과 개발 시간을 절약하기 위해 재구성하여 새로운 시스템에 기능 개발에 최적화 하는것
- 누구나 이해 가능하고 공개해야 한다
- 외부 모듈과의 결합도는 낮고 응집도는 높아야함
#### 규모에 따른 분류
- 함수와 객체
    - 클래스나 메소드 단위의 소스코드를 재사용
- 컴포넌트
    - 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성
    - 수정 없이 인터페이스를 통신하는 방식으로 작성
- 애플리케이션
    - 공통되는 기능들을 공유

## 3. 효과적인 모듈 설계 방안
- 결합도는 줄이고 응집도는 높여서 모듈의 독립성, 재사용성 높임
- 제어 영역 안에서 영향 영역을 유지시킨다
- 복잡도와 중복성을 줄이고 일관성을 유지
- 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이면 안됨
- 유지보수가 용이
- 크기는 시스템 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해
- 하나의 입구와 출구를 갖음
- 전반적인 코드에 오류가 없이 인터페이스 설계
- 계층적 관계를 저의하는 자료가 제시되어야 한다
# 3. 코드
## 코드 개요
- 컴퓨터 자료를 처리하는 과정으로 특정 자료의 추출을 쉽게하기 위한 기호
- 정보를 신속,정확,명료하게 전달
- 일정한 규칙에 작성, 효율과 처리된 정보의 가치에 많은 영향
-----
- 식별 기능
    - 성격에 따라 구분
- 분류 기능
    - 특정 기준이나 동일 유형으로 그룹화
- 배열 기능
    - 의미를 부여 나열
- 표준화 기능
    - 데이터 기준에 맞춰 표현
- 간소화 기능
    - 복잡한 데이터 간소화
## 2. 코드의 종류
- Sequence
    - 순차적으로 부여, 일련번호 코드 , 순차 코드
- Block
    - 공통성이 있는 것을 블록으로 묶음, 구분 코드
- Deciaml
    - 0~9로 분할, 도서분류식 코드
- Group Classification
    - 대,중,소등으로 구분하고 일련번호 부여
- Mnemoncie
    - 명칭, 약칭으로 관계있는 문자,숫자로 부여
- Significant Digit
    - 물리적 수치를 코드에 대입
- Combined
    - 필요한 기능을 하나의 코드로 만들기 어려울 때 조합하여 코드 만듬
## 3. 코드 부여 체계
- 용도와 적용 범위를 알 수 있도록 부여
- 식별 및 추출에 용이
- 객체를 나타내는 코드등이 정의 되어야함
- 상세하게 명시함

# 2. 디자인 패턴
## 1. 개요
- 세분화된 역할이나 모듈간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조하는 전형적인 방식 or 예제
- 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드로 구성
- 새로운 해결책보다 만드러 진것을 참조해서 만드는 것이 효율적
- Gof

## 2. Gof 장 단점
- 장점
    - 범용적인 코딩 스타일로 인해 구조 파악이 용이
    - 객체지향 설계 및 구현의 생산성을 높이는 데 적합
    - 검증된 구조의 재사용을 통해 시간과 비용 절감
    - 개발자 간의 원활한 의사소통 가능
    - 설계 변경 요청에 유연하게 대응 가능
- 단점
    - 초기 투자 비용 부담
    - 객체지향 기반 설계와 구현을 다룸으로 다른 기반의 애플리케이션 개발에는 부적합
## 3.Creational(생성)
- 생성과 참조 과정을 캡슐화 하여 객체가 생성되거나 변경되어도 프로그램 구조에 영향이 없도록 함
#### 종류
- Abstact Factory(추상화 팩토리)
    - 클래스에 의존하지 않고 서로 연관 의존하는 객체들을 그룹으로 생성하여 추상화
    - 서브 클래스를 묶어 한번에 교체 가능
- Builde
    - 작게 분리된 인스턴스를 건설하듯 조합하여 생성
    - 생성과정과 표현 방법을 분리, 동일한 객체 생성에서도 서로 다른 결과 가능
- Factory Method
    - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화
    - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당
    - 가상 생성자 패턴
- Protoltype
    - 원본을 복제하는 방법으로 객체를 생성하는 패턴
    - 일반적인 방법으로 객체를 생성하고 비용이 큰경우 주로 이용
- Singleton
    - 어디든 참조 가능 하지만 다중 참조는 안됨
    - 하나뿐임을 보장하며 메모리 당비를 최소화
## 4. 구조 패턴(Structural)
- 클래스를 조합하여 더 큰 구조 생성
#### 종류
- Adapter
    - 호환성 없는 클래스를 인터페이스를 다른 클래스가 이용할 수 있도록함
    - 기존 클래스가 일치하지 않을 때 주로 사용
- Bridge
    - 추상층을 분리하여 서로 독립적으로 확장 가능하게함
    - 기능과 구현 별도의 클래스로 구성
- Composite
    - 여러 객체를 가지 복함객체와 단일 객체를 구분 없이 다룰 때 사용
    - 트리 구조로 복합 객체 안에 복합 객체를 구현 가능
- Decorator
    - 객체 간의 결합을 통해 능동적으로 확장
    - 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 형식
- Facade
    - 더 상위 인터페이스를 구성함으로 서브 클래스의 기능을 간편하게 사용가능
    - Wapper 객체가 필요
- Flayweight
    - 매번 생성이 아닌 공유해서 사용하여 메모리 절약
    - 다수의 유사 객체를 사용할 때 용이
- Proxy
    - 접근이 어려운 객체와 연결하려는 객체 사이의 인터페이스 역할
    - 네트워크 메모리 대용량 객체 접근 시 사용
## 5. 행위 패턴(Behavioral)
- 서로 다른 객체 상호작용하는 법이나 책임 분배 방법을 정의
- 하나의 객체로 수행할수 없는것들을 결합도를 최소화 할수 있게 도와줌
#### 종류
- Chain of Responsibility(책임 연쇄)
    - 요청 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
    - 고리로 묶여 있어 요청이 해결 될때 까지 고리에 따라 책임 전과
- Command
    - 캡슐화하여 재사용 및 취소 할 수 있도록 요청하여 필요한 정보 저장 및 기록
    - 추상, 구체 매소드로 분리하여 단순화
- Interpreter
    - 언어에 문법 표현을 정의
    - SQL or 프로토콜 
- Iterator
    - 접근이 잦은 인터페이스를 사용
    - 내부 표현 방법의 노출없이 순차적 접근
- Mediator
    - 상호작용을 캡슐화 하여 객체 정의
    - 객체들의 의존성을 줄여 결합도 감소
    - 통제와 지시 역할 수행
- Memento
    - 되돌리기 기능
    - 내부 상태를 객체화함으로 요청에 따라 해당 시점으로 되돌림
- Observer
    - 한 객체의 상태가 변화하면 상속되어 있는 자식들에게 변화된것을 전달
    - 주로 분산된 시스템 간에 이벤트를 생성, 발행하고, 수신할때 필요
- State
    - 객체 상태의 캡슐화하고 이를 참조하는 방식으로 처리
    - 동일한 동작을 다르게 처리해야 할때 사용
- Strategy
    - 동일 계열 알고리즘을 개별로 추상화 하여 상호 교환할수 있게 정의
    - 독립적으로 원하는 알고리즘을 선택하여 클라이언트에 지장없이 사용
- Template Method
    - 상위 클래스 골격을 정의, 하위 클래스에서 세부 처리 구현화
    - 유사한 클래스를 묶어 상위 클래스에 정의함으로 코드 수 줄임
- Vistior
    - 데이터 구조에서 처리 기능을 분리하여 별도 클래스를 만듬
    - 분리된 처리 능력을 각 클래스에 방문
    