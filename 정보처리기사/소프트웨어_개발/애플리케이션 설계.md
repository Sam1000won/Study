# 1. 애플리케이션 설계
## 1 소프트웨어 아키텍처의 설계
- SW의 골격이 되는 기본 구조/ 구성하는 요소들 간의 관계를 표현
- 적용되는 원칙과 지침
- 품질을 유지하면서 요구사항을 반영, 구현, 방법 해결
- 분할 방법과 분할 할당되는 방법
-----
- 상위 설계
    - 아키텍처 설계
    - 예비 설계
    - 시스템 전체 구조
    - 구조, DB, InterFace
- 하위 설계
    - 모듈 설계, 상세 설계
    - 시스템의 내부 구조 및 행위
    - 컴포넌트, 자료구조, 알고리즘
-----
## 2.모듈화(Modularity)
- 시스템 성능 향상, 재사용성, 유지관리를 용이하도록 기능을 나눔
- 공통모듈을 만들어 재사용성 높임
- 모듈이 크기를 작게 나누면 통합 비용 증가
- 모듈의 크기를 크게 하면 나누는 비용 증가
- 기능의 분리가 가능하여 인터페이스 단순화
- 오류의 파급효과를 최소화
## 3. 추상화(Abstraction)
- 문제의 전체적이고 포괄적인 개념을 설계 후 세분화, 구체화
### 유형
- 과정 추상화
    - 수행 과정을 정의하지 않고 흐름을 파악할 수 있게 설계
- 데이터 추상화
    - 데이터 세부 속성을 정의하지 않고 구조를 대표할 수 있게 설계
- 제어 추상화
    - 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할수 있는 표현을 하는 방법
## 4. 단계적 분해(Stepwise Refinement)
- Niklaus Wirth에 의해 제안된 하향식 설계 전략
- 추상화를 반복에 의해 세분화
- 점진적으로 구체화, 알고리즘등 내역에 가능한 뒤로 미뤄  진행
## 5. 정보 은닉(Information Hiding)
- 정보가 감추어 져 다른 모듈이 접근 하거나 변경 못하게 하는것
- 필요한 기능을 사용할 때 필요 정보만 인터페이스 제공
- 독립적 수행 가능, 수정, 시험, 유지보수 용이
## 6. 소프트웨어 아키텍처 품질 속성
- 관계자 요구 수준에 맞춰 품질 유지, 보장 설계 확인 및 구체화
### 시스템
- 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성
### 비즈니스
- 시장 적시성, 비용과 혜택, 예상 시스템 수명
### 아키텍처
- 개념적 무결성, 정확성, 완결성, 구축 가능성
## 7. 설계 과정
- 목표 설정 -> 타입 결정 -> 패턴(디자인)적용 -> 구체화 -> 검토
### 협약에 의한 설계
- Precondition(선행 조건): 호출 전 참이 되는것
- Postcondition(결과 조건): 호출 후 만족해야 할 조건
- Invariant(불변): 실행하는 동안 참이여야 할 조건
# 2. 아키텍쳐 패턴
## 1. 패턴 개요
- 전형적인 해결 방식 또는 예제를 의미
- 기본적인 윤곽을 제시
- 서브시스템과 역할을 정의 규칙과 관계 지침등을 포함
- 스타일, 혹은 표준 아키텍쳐라함
### 장점
- 개발 시간 단축, 고품질 SW 생산
- 안정적 개발
- 이해관계자와 공통 아키텍쳐 공유로 의사소통 간편
- 개발과 유지 보수가 쉬워짐
- 개발 전에 예측이 가능

## 2. 레이어 패턴
- 계층을 구성하는 고전적인 방법
- 각 층은 하위 상위 계층에 대한 서비스 제공자, 상위 계층은 클라이언트가 된다
- 서로 마주보는 층만 상호작용과 변경 사항 적용이 가능함 따라서 작업이 용이
- 특정 계층만 교체해 시스템 개선이 가능
- OSI 참조 모델
## 3.Clinet - Server
- 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성
- 서버 컴포넌트는 항상 대기중이다
- 동기화를 제외하고는 서로 독립적
## 4. Pipe-Fiter
- 데이터 스트림 절차의 각 단계를 캡슐화하여 데이터 전속
- 재사용성과 확장이 좋다
- 재배치로 새로운 파이프라인 구축 가능
- 데이터 변환, 버퍼링, 동기화등에 주로 사용
- 데이터 이동시 변환으로 인한 오버해드 발생
- Unix 쉘
## 5.Mode-View-Controller
- Model: 서브시스템의 핵심 기능과 데이터 보관
- View: 사용자에게 정보 표시
- Controller: 입력된 변경 요청을 처리하는 명령 전송
- 서로 분리되어 있어 개발 시 영향 적음
- 대화형 애플리케이션에 유리
### 기타 패턴
#### Master-Slave
- 장애 허용 시스템과 병렬 컴퓨팅시스템에 주로 활용
- 마스터는 작업의 주체, 슬레이브는 작업수행 결과를 반환
#### Broker
- 사용자가 원하는 서비스와 특성을 연결
- 원격 서비스 호출이 많을 때 유리함
- 분산 환경 시스템에서 주로 활용
#### Peer-To-Peer
- 호출하는 클라이언트가 될수도 제공하는 서버가 될 수 있음
- 전형적인 멀티스레딩 방식을 사용
#### Event-Bus
- 이벤트를 생성하는 소스
- 이벤트를 수행하는 리스너
- 이벤트의 통로 채널
- 채널을 관리하는 버스
- 이벤트 메시지를 발행하면 구독한 리스너에게 메시지를 전송
#### Blackboard
- 검색시 원하는 블랙보드에서 데이터를 찾을 수 있음
- 해결책이 명확하지 않을 때 유용함
- 음성,차량,신호 해석등에 사용
#### Interpreter
- 각라인을 수행하는 방법을 지정
- 특정 언어로 프로그램 코드를 해석하는 컴포넌트 설계할 때 사용
## 3. 객체지향
### 1. 개요
- 소프트웨어를 개발 할때 조립해서 작성할 수 있는 기법
- 구조적 문제를 해결하기 위해 만듬
- 재사용성 및 확장에 용이, 유지보수 쉬움
- 복잡한 구조를 단계적, 계층적으로 표현 병렬처리 가능
- 모형화 함으로 개발자, 사용자 쉽게 이해
- 객체, 클래스, 캡슐화, 상속, 다형성, 연관성이 있음
### 2. Object
- Data
    - 속성, 상태, 자료구조
    - 객체가 가지고 있있는 정보
- Funtion
    - 객체가 수행하는 기능으로 객체가 갖는 알고리즘
    - 메서드, 서비스, 동작, 연산
#### 특성
- 독립적으로 식별 가능한 이름을 가짐
- 조건을 상태라고함 시간에 따라 변함
- 상호 연관성에 의한 관계
- 객체가 반응할 수 있는 메시지의 집합,행위 특징을 나타낼수 있음
- 일정한 기억장소를 갖음
## 3. Class
- 공통된 속성과 연산(행위)를 갖는 객체의 집합 일반적 Type
- 속성과 연산을 정의하는 툴
- 데이터 추상화하는 단위
- 각 객체를 Instance, 새로운 객체를 만드는것을 Instantiation
- 동일 클래스를 속성과 해위를 가지면서 여러 객체를 나타냄
- 슈퍼 클래스는 특정 클래스의 상위 클래스이며, 서브클래스는 하위 자식을 의미
## 4. Encapsulation
- 데이터(속성)와 데이터를 처리하는 함수를 하나로 묶음
- 정보 은폐되어 외부에서 접근이 불가능하므로 파수 효과가 적음
- 재사용에 용이
- 단순해지고 객체의 결합도는 낮아짐
## 5. Inheritance
- 상위 클래스의 모든 속성을 하위 클래스에 물려주는 것
- 자기 자신을 호출하지 않아도 자신의 속성을 사용가능
- 새로운 속성과 연산자를 첨가하여 사용 가능
## 6. Polymorphism
- 오버로딩
    - 메소드의 이름은 같지만 인수를 받는 자료형의 갯수를 여러개 정의 가능
- 오버라이딩
    - 메소드의 이름을 재사용하여 사용할 수 있다
- 하나의 메시지에 대해 객체가 가지고 있는 특성을 응답할 수 있는 능력
## 7. Relationship
- 두 개 이상의 객체들이 상호 참조하는 관계를 말함
- is member of
    - Associaion
        - 2개 이상의 객체가 상호 연관
- is instance of
    - Classfication
        - 동일한 형의 특성을 객체들을 모아 구성
- is part of
    - Aggregation
        - 관련 있는 객체들을 묶어 하나의 상위 객체로 구성
- is a
    - Generalization
        - 추상화한 상위 객체를 구성
    - Specialization
        - 상위 객체를 구체화하여 하위 객체를 구성
# 3. 객체지향 분석 및 설계
## 1. 객체지향 분석의 개념
- OOA 사용자의 요구사항을 분석하여 요구된 문제와 관련 객체, 속성과 연산, 관계등을 정의하여 모델링
- 업무를 객체와 속성, 등으로 나눠 분석
- 분석가에게 표현해서 모형화함
- 객체는 클래스로부터 인스턴스화, 클래스를 식별하는 것이 분석의 주요 목적
## 2. 방법론
- Rumbaugh
    - 일반적 사용 방법, 객체모델, 동적모델, 기능 모델로 나눠사용
- Booch
    - 미시적 개발 프로세스와 거시적 프로세스로를 모두 사용하는 분석 방법
- Jacobson
    - Use Case를 강조하는 분석(외부 시스템등 상호 작용하는 기술)
- Coad, Yourdon
    - E-R 다이어그램을 사용하여 객체의 행위를 모델링, 객체식별, 구조식별, 주제정의등 구성하는 기법
- Wirts-Block
    - 분석과 설계 간의 구분이 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행
## 3. Rumbaugh (OMT)
- 객체 모델링 -> 동적 모델링 -> 기능 모델링
- 객체 모델링(정보 모델링/Object Modeling)
    - 시스템에서 요구되는 객체를 찾아 속성과 연산, 관계를 구정하며 객체 다이어그램으로 표시
- 동적 모델링(Dynamic Modeling)
    - 상태 다이어그램을 이용하여 시간의 흐름에 따라 제어 흐름 상호작용, 동작 순서를 표현
- 기능 모델링(Functional Modeling)
    - DFD를 이용하여 다수의 프로세스를 자료 흐름을 중심으로 처리하는 과정을 표현

## 4. 객체 지향 설계 원칙
### 1. 단일 첵임 원칙(SRP/ Single Responsibility Principle)
- 객체는 단하나의 책임만 가져야 하는 원칙
- 응집도는 높고 결합도는 낮게 설계하는 것을 의미
### 2. 개방-폐쇄 원칙(OCP/ Open=Closed Principle)
- 기존 코드를 변경하지 않고 기능을 추가할 수 있도록 설계
- 공통 인터페이스를 하나로 묶어 캡슐화
### 3. 리스코프 치환 원칙(LSP/ Liskov Substitution Principle)
- 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위를 수행할 수 있게 설계 원칙
- 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 하도록 사용
### 4. 인터페이스 분리 원칙(ISP/ Interfcce Segregation Principle)
- 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야함
- 단일 책임 원칙이 객체 하나의 책임이면 인터페이스 하나에 하나의 책임
### 5. 의존 역전 원칙(DIP/ Dependency Inversion Priciple)
- 각 객체간의 의존관계가 성립될 때, 추상성이 낮은 클래스보다, 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙
- 일반적으로 인터페이스를 활용하면 이 원칙을 준수
